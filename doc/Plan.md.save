# Software Development Plan

## Phase 0: Requirements Specification
*(20% of your effort)*

**Important - do not change the code in this phase**

Deliver:

*   [ ] Re-write the instructions in your own words.
    *   If you don't do this, you won't know what you're supposed to do!
    *   Don't leave out details!

    *   TEXT STARTS HERE: Our goal is to make text-processing programs in Python that works from the command line and chooses a tool to use, all of which are Python functions that use input from the command line. Tools that the customer wants rewritten in Python are cat, tac, cut, paste, grep, head, tail, sort(uses Python built-in), and wc, which are designed in Phase 1. The "driver" program tt.py will use command line arguments and files as input without the Python built-in 'input()', calling on separate Python modules to do the function the user inputs. Helpful error messages will be shown if the user inputs incorrect arguments and the program will quit (use Python's built-in error messages). 	
*   [ ] Explain the problem this program aims to solve.
    *   This program aims to recreate classes Unix text-tools in Python as similarly as possible 
    *   Describe what a *good* solution looks like.
    *   A 'good' solution is one where the input in the command line of the form 'python src/tt.py TOOL [OPTIONS] FILENAME...' outputs the same thing as the Unix text-tools would, without errors
    *   List what you already know how to do.
    *   CONTINUE: I know how to make an okay SDP and debug code pretty well. I know how to evaluate a program based on the code inside it and what it is meant to do
    *   Point out any challenges that you can foresee.
    *   CONTINUE: I can see that staying motivated to do something so mundane and redundant will be a challenge, 
*   [ ] List all of the data that is used by the program, making note of where it comes from.
    *   Explain what form the output will take.
    *   TEXT BEGINS HERE: Inputs are given in the command line with the form 'python src/tt.py TOOL [OPTIONS] FILENAME...'. 'python' and 'src/tt.py' call the program, and 'TOOL' tells it which of the tools to use(must be input in lower-case). '[OPTIONS]' is optional and dependent on which tool is being called(brackets should not be typed, begin with a hyphen, and may accept arguments of their own. 'FILENAME' is obviously the file(s) the user wants the 'TOOL' to act on, and must be completely and correctly input(ends with .txt, .py, etc.). All of these arguments should be treated as strings, and if it should be used as a number use 'int()' to convert it to an integer. 
    *   Outputs will be as follows:
        1. cat: Connects all files together and prints them top to bottom
	2. tac: Connects all files together and prints them bottom to top
	3. cut: Removes the selected portion from each selected file and saves what it was as a string
	4. paste: Inputs the saved string from 'cut' into the file(s)
	5. grep: Prints lines of file(s) that match the input given
	6. head: Prints to the console the first part of the file(s)
	7. tail: Prints to the console the last part of the file(s)
	8. sort: Sorted lines of text file(s)
	9. wc: Prints to the console on a new line, word count, and byte counts for each file 
*   [ ] List the algorithms that will be used (but don't write them yet).


## Phase 1: Design
*(30% of your effort)*

**Important - do not change the code in this phase**

Deliver:

*   [ ] Function signatures that include:
    *   Descriptive names.
    *   Parameter lists.
    *   Documentation strings that explain its purpose and types of inputs and outputs.
*   [ ] Pseudocode that captures how each function works.
    *   Pseudocode != source code.  Do not paste your finished source code into this part of the plan.
*   Explain what happens in the face of good and bad input.
    *   Write a few specific examples that occur to you, and use them later when testing


## Phase 2: Implementation
*(15% of your effort)*

**Finally, you can write code!**

Deliver:

*   [ ] More or less working code.
*   [ ] Note any relevant and interesting events that happened while you wrote the code.
    *   e.g. things you learned, things that didn't go according to plan


## Phase 3: Testing and Debugging
*(30% of your effort)*

Deliver:

*   [ ] A set of test cases that you have personally run on your computer.
    *   Include a description of what happened for each test case.
    *   For any bugs discovered, describe their cause and remedy.
    *   Write your test cases in plain language such that a non-coder could run them and replicate your experience.


## Phase 4: Deployment
*(5% of your effort)*

Deliver:

*   [ ] Your repository is pushed to GitLab.
*   [ ] **Verify** that your final commit was received by browsing to its project page on GitLab.
    *   Ensure the project's URL is correct.
    *   Review the project to ensure that all required files are present and in correct locations.
    *   Check that unwanted files have not been included.
    *   Make any final touches to documentation, including the Sprint Signature and this Plan.
*   [ ] **Validate** that your submission is complete and correct by cloning it to a new location on your computer and re-running it.
	*	Run your program from the command line so you can see how it will behave when your grader runs it.  **Running it in PyCharm is not good enough!**
    *   Run through your test cases to avoid nasty surprises.
    *   Check that your documentation files are all present.


## Phase 5: Maintenance

Spend a few minutes writing thoughtful answers to these questions.  They are meant to make you think about the long-term consequences of choices you made in this project.

Deliver:

*   [ ] Write brief and honest answers to these questions:
    *   What parts of your program are sloppily written and hard to understand?
        *   Are there parts of your program which you aren't quite sure how/why they work?
        *   If a bug is reported in a few months, how long would it take you to find the cause?
    *   Will your documentation make sense to...
        *   ...anybody besides yourself?
        *   ...yourself in six month's time?
    *   How easy will it be to add a new feature to this program in a year?
    *   Will your program continue to work after upgrading...
        *   ...your computer's hardware?
        *   ...the operating system?
        *   ...to the next version of Python?
*   [ ] Make one final commit and push your **completed** Software Development Plan to GitLab.
*   [ ] Respond to the **Assignment Reflection Survey** on Canvas.
